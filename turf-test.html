<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title>turf-polygon</title>
<meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src='js/turf.min.js'></script>
<script src='js/martinez.umd.js'></script>
<script src='js/austria-250m.js'></script>
<script src='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.css' rel='stylesheet' />

<style>
  body { margin:0; padding:0; }
  #map { position:absolute; top:0; bottom:0; width:100%; }
</style>
</head>
<body>
<div id='map'></div>

<script>
L.mapbox.accessToken = 'pk.eyJ1IjoiZ2NzYWx6YnVyZyIsImEiOiJjam1pNm5uZmcwMXNyM3FtNGp6dTY3MGxsIn0.PmLPkI3T8UxjEIPnz7fxEA';

var map = L.mapbox.map('map', 'jvrousseau.h4h90e5o').setView([47.414591, 13.388446], 7);

initMap();

function initMap() {

    // Variables
    var increments = 5;                             // Number of sV in each isoband
    var grid_size = 10;                             // Distance between grid points, smaller = slower (km)
    var grid_extent = [9.25, 46.25, 17.45, 49.1];   // Size of grid to produce
    var interp_weight = 10;                         // Exponent decay constant for interpolation grid (bigger = faster decay)
    var calc_method = 'interpolate';                    // nearest || average || interpolate

    // Visibility flags
    var show_austria        = false;
    var show_raw_points     = false;
    var show_tin_polygons   = false;
    var show_grid_points    = false;
    var show_isobands       = true;

    // Outline of Austria
    var austria_poly = JSON.parse(austria_outline_json);

    var min_Rad = 100000000;
    var max_Rad = 0;
    var lower_bound;
    var upper_bound;

    var items = {};

    // Get JSON list of places
    $.getJSON( "http://sfws.lfrz.at/json.php",{command: "getstations"}).done(function(data){
        $.each( data, function( key, val ) {
            items[key] = {
                "n": val.n,
                "x": val.x,
                "y": val.y,
                "lat":((-0.00767*val.y)+49.00947),  // Magic numbers!
                "lng":((0.011317*val.x)+9.516872),
                "val":0.0
            };
        });
        $.getJSON( "http://sfws.lfrz.at/json.php",{command: "getdata"}).done(function(data){
            $.each( data.values, function( key, val ) {
                items[key].val = val.v;
                if(val.v > max_Rad){
                    max_Rad = val.v;
                }
                if(val.v < min_Rad){
                    min_Rad = val.v;
                }
            });
            console.log({min_Rad,max_Rad});
            build_heatmap(items);
        });
        
    });


    function build_heatmap(items){
        
        // Update bounds for graphics now
        lower_bound = Math.floor(min_Rad/increments)*increments;
        upper_bound = Math.ceil(max_Rad/increments)*increments;

        // Add outline of Austria to map
        if(show_austria){
            L.geoJson(austria_poly,{fillOpacity:1, weight:2, color:'#ffffff'}).addTo(map);
        }

        // Create an array of points from the heatmap data values (TODO : move this into $.getJSON above in future)
        var rawDataArray = [];
        $.each(items, function(k,v){
            var loc = turf.point([v.lng, v.lat], {radiation: v.val});
            rawDataArray.push(loc);
        });

        // Create featureCollection of unstructured data points
        var rawDataPoints = turf.featureCollection(rawDataArray);

        // Add unique identifier to each point (e.g. to be used in back reference from TIN coords)
        var index = 0;
        rawDataPoints.features.forEach(function(feat) {
            feat.properties.ref = index;
            index++;
        });

        // Add unstructured data points to map
        if(show_raw_points){
            rawDataPoints.features.forEach(function(feat) {
                var lat = feat.geometry.coordinates[1];
                var lng = feat.geometry.coordinates[0];
                L.circle([lat,lng], feat.properties.radiation*100, {stroke: false, fillOpacity: 0.7, color: '#0000ff'}).addTo(map);
            });
        }

        // Choose which method to calculate the radiation value for the points by
        switch(calc_method){

            // Method A: Calculate which unstructured data point each point is nearest to    
            case 'nearest': 

                // Create the grid
                var grid = turf.pointGrid(grid_extent, grid_size, {units: 'kilometres'});

                L.geoJson(grid, {
                    onEachFeature: function (feature, layer) {
                        var near_point = turf.nearestPoint(feature,rawDataPoints);
                        feature.properties.radiation = near_point.properties.radiation;
                    }
                });        
                break; 

            // Method B: Calculate TIN polygons and determine which polygon each point lies within
            case 'average':

                // Create TIN polygons
                var tin_polys = turf.tin(rawDataPoints, 'ref');

                // Add radiation sum as property to each tin poly.
                L.geoJson(tin_polys,{
                    onEachFeature: function (polyfeat, layer) {
                        var radiation_sum = 0;
                        var fp = polyfeat.properties;
                        rawDataPoints.features.forEach(function(rawPoint) {
                            var rpp = rawPoint.properties;
                            if((rpp.ref == fp.a)||(rpp.ref == fp.b)||(rpp.ref == fp.c)){
                                radiation_sum += rpp.radiation;
                            }
                        });
                        fp.radiation = radiation_sum/3;
                }});

                // Add TIN polygons to the map
                if(show_tin_polygons){
                    L.geoJson(tin_polys,{
                        style: function(feature){
                            var opts = {
                                fillOpacity:    0.4,
                                weight:         1,
                                color:          '#000000',
                                fillColor:      perc2color(rad2perc(feature.properties.radiation))
                            };
                            return opts;
                        }
                    }).addTo(map);
                }

                // Create the grid
                var grid = turf.pointGrid(grid_extent, grid_size, {units: 'kilometres'});

                // Calculate which tin poly each point is inside
                L.geoJson(grid, {
                    onEachFeature: function (feature, layer) {
                        feature.properties.radiation = 0;
                        tin_polys.features.forEach(function(tin_feat) {
                            if(turf.booleanPointInPolygon(feature,tin_feat)){
                                feature.properties.radiation = tin_feat.properties.radiation;
                                return false; // break out of forEach to save computation cycles
                            }
                        });
                    }
                });
                break;

            // Method C: Calculate which unstructured data point each point is nearest to    
            case 'interpolate': 

                // Add "fake" duplicate points just outside the bounds to stretch coverage across whole of Austria
                var rawDataFeatures = rawDataPoints.features;
                rawDataFeatures.push(turf.point([15.451882,49.013285],{radiation: items["AT0716"].val})); // Waidhofen/Ybbs
                rawDataFeatures.push(turf.point([14.887182,49.032998],{radiation: items["AT0514"].val})); // Gmünd/NÖ
                rawDataFeatures.push(turf.point([14.549704,46.312700],{radiation: items["AT0305"].val})); // Bad Eisenkappel
                rawDataFeatures.push(turf.point([9.442690,47.210770],{radiation: items["AT1906"].val}));  // Feldkirch
                rawDataFeatures.push(turf.point([17.224055,48.144801],{radiation: items["AT0520"].val}));  // Hainburg
                rawDataFeatures.push(turf.point([17.225467,47.799404],{radiation: items["AT0104"].val}));  // Frauenkirchen
                rawDataPoints = turf.featureCollection(rawDataFeatures);

                // Create interpolation grid
                var grid = turf.interpolate(rawDataPoints, grid_size, {
                    gridType: 'points',
                    property: 'radiation',
                    units: 'kilometres',
                    weight: interp_weight
                })
                break;
        }

        // Now deal with the points outside the bounds of the measured values.
        // We give these a nearest-neighbour value, to fill out the small edges of the outline of Austria which would otherwise be missed
        L.geoJson(grid, {
            onEachFeature: function (feature, layer) {
                if(feature.properties.radiation == 0){
                    feature.properties.radiation = turf.nearestPoint(feature,rawDataPoints).properties.radiation;
                }
            }
        });

        // Add structured grid points to map
        if(show_grid_points){
            L.geoJson(grid, {
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, {
                        // Stroke properties
                        color: '#000',
                        opacity: 0.75,
                        weight: 2,
                        stroke: false,

                        // Fill properties
                        fillColor: perc2color(rad2perc(feature.properties.radiation)),
                        fillOpacity: 1,
                        radius: 6
                    });
                }
            }).addTo(map);
        }

        // Calculate isoband intervals and properties
        var breaks = [];
        var band_properties = [];
        for(i=lower_bound; i<=upper_bound; i+=increments){
            breaks.push(i);
            band_properties.push({radiation_lower:i});
        }

        // Create the isobands
        var isobands = turf.isobands(grid,breaks,{zProperty: 'radiation', breaksProperties: band_properties});

        // Crop them to the size of Austria (which is the only area we have valid data for)
        // We use Martinez for this
        var croppedisobands_array = [];
        var i=0;
        L.geoJson(isobands, {
            onEachFeature: function (feature, layer) {
                // Filter out isobands with no geometry in them to avoid Martinez crashing
                if(feature.geometry.coordinates.length > 0){
                    croppedisobands_array.push({
                        type: "Feature",
                        properties: feature.properties,
                        geometry: {
                            type: "MultiPolygon",
                            coordinates: martinez.intersection(feature.geometry.coordinates,austria_poly.geometry.coordinates)
                        }
                    });
                }
            }
        });  
        var croppedisobands = turf.featureCollection(croppedisobands_array);  

        // Draw isobands
        if(show_isobands){
            L.geoJson(croppedisobands,{
                onEachFeature: function(feature, layer){
                    if (feature.properties && feature.properties.radiation) {
                        layer.bindPopup(feature.properties.radiation);
                    }
                },
                style: function(feature){
                    var opts = {
                        fillOpacity:    0.9,
                        weight:         1,
                        stroke:         false,
                        color:          '#000000',
                        fillColor:      perc2color(rad2perc(feature.properties.radiation_lower)),
                    };
                    return opts;
                }
            }).addTo(map);
        }

    }

    // Scales a radiation value between the maximum and minimum possible values
    function rad2perc(rad_values){
        return (rad_values-lower_bound)*100/(upper_bound-lower_bound);       
    }

    // Return a hex colour from red -> yellow -> green depending upon input percentage (0 -> 100)
    function perc2color(perc) {
        var r, g, b = 0;

        perc = 100-perc; // invert so green = low number

        if(perc < 50) {
            r = 255;
            g = Math.round(5.1 * perc);
        }
        else {
            g = 255;
            r = Math.round(510 - 5.10 * perc);
        }
        var h = r * 0x10000 + g * 0x100 + b * 0x1;
        return '#' + ('000000' + h.toString(16)).slice(-6);
    }
};
</script>
</body>
</html>