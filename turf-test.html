<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title>turf-polygon</title>
<meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
<script src="https://code.jquery.com/jquery-3.3.1.min.js"
integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
crossorigin="anonymous"></script>
<script src='js/turf.min.js'></script>
<script src='js/martinez.umd.js'></script>
<script src='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.css' rel='stylesheet' />

<style>
  body { margin:0; padding:0; }
  #map { position:absolute; top:0; bottom:0; width:100%; }
</style>
</head>
<body>
<div id='map'></div>

<script>
L.mapbox.accessToken = 'pk.eyJ1IjoiZ2NzYWx6YnVyZyIsImEiOiJjam1pNm5uZmcwMXNyM3FtNGp6dTY3MGxsIn0.PmLPkI3T8UxjEIPnz7fxEA';

var map = L.mapbox.map('map', 'jvrousseau.h4h90e5o').setView([47.414591, 13.388446], 7);

initMap();

function initMap() {

    // Variables
    var increments = 5;    // Number of sV in each isoband
    var cellSide = 10;      // Distance between grid points, smaller = slower (km)

    
    // Outline of Austria

   
    var austria_outline_json = '{"type": "Feature", "properties":{}, "geometry": {"type":"Polygon","coordinates":[[[13.44451904296875, 48.55661410872126],[13.43902587890625, 48.449243890328724],[13.3319091796875, 48.32521295617702],[13.14239501953125, 48.28502057399577],[13.00506591796875, 48.25028349849022],[12.873229980468748, 48.193556524687395],[12.7496337890625, 48.103763074117765],[12.8924560546875, 47.95314495015594],[12.98583984375, 47.837127072368524],[12.90069580078125, 47.72269690266809],[13.04351806640625, 47.71715357016648],[13.10394287109375, 47.61356975397398],[13.04901123046875, 47.541309583656854],[12.98858642578125, 47.46152250874388],[12.76611328125, 47.57467282332527],[12.829284667968748, 47.61727271567975],[12.73040771484375, 47.67648444221321],[12.59307861328125, 47.67648444221321],[12.5738525390625, 47.633932798340716],[12.42828369140625, 47.69127688626756],[12.24151611328125, 47.702368466573716],[12.161865234375, 47.69312564683551],[12.2003173828125, 47.60986653003798],[11.97784423828125, 47.619124098197325],[11.8212890625, 47.585789182379905],[11.63726806640625, 47.589494110887394],[11.5631103515625, 47.517200697839414],[11.42578125, 47.5153457091302],[11.4093017578125, 47.454094290400015],[11.22802734375, 47.402067376409036],[10.997314453125, 47.402067376409036],[10.90118408203125, 47.52091047852614],[10.689697265625, 47.55428670127958],[10.46722412109375, 47.570966845786124],[10.42877197265625, 47.416937456635445],[10.360107421875, 47.342545069660225],[10.2777099609375, 47.29413372501023],[10.107421874999998, 47.372314620566925],[10.052490234375, 47.48380086737799],[9.939880371093748, 47.53203824675999],[9.788818359374998, 47.58764167941513],[9.68719482421875, 47.53203824675999],[9.5855712890625, 47.53018378265907],[9.64324951171875, 47.44666502261753],[9.6185302734375, 47.36115300722623],[9.5196533203125, 47.25686404408872],[9.60479736328125, 47.178512264439085],[9.6405029296875, 47.135556272359196],[9.61578369140625, 47.06450941441436],[9.879455566406248, 47.010225655683485],[9.88494873046875, 46.933385414813955],[10.0579833984375, 46.854556538855746],[10.250244140625, 46.88647742351024],[10.30792236328125, 46.931509883369316],[10.39031982421875, 46.9989876381546],[10.48095703125, 46.93901161506044],[10.469970703124998, 46.85079989251277],[10.65948486328125, 46.869580496513265],[10.77484130859375, 46.80569963924226],[11.01104736328125, 46.77184961467733],[11.1566162109375, 46.96713374957253],[11.346130371093748, 46.98962081759436],[11.41204833984375, 46.96713374957253],[11.51092529296875, 47.00460694243501],[11.62628173828125, 47.00273390667881],[11.75262451171875, 46.96900803311957],[12.18658447265625, 47.09630525444073],[12.238769531249998, 47.075733642316195],[12.12615966796875, 46.991494313050424],[12.2222900390625, 46.880845705719146],[12.27996826171875, 46.85831292242506],[12.27996826171875, 46.79253827035982],[12.3651123046875, 46.76620587423741],[12.466735839843748, 46.68336307047754],[12.81005859375, 46.6268063953552],[13.27423095703125, 46.5607488448596],[13.941650390625, 46.50217348354072],[14.441528320312498, 46.428392162921234],[14.5733642578125, 46.379149058330746],[14.724426269531252, 46.5002829039397],[14.7930908203125, 46.50406399740093],[14.886474609375, 46.61171462536894],[15.065002441406248, 46.66263249079177],[15.44677734375, 46.62303384721474],[15.575866699218748, 46.67582559793001],[15.845031738281248, 46.7248003746672],[16.01806640625, 46.66074749832068],[15.993347167968752, 46.83389173208538],[16.19659423828125, 46.92025531537451],[16.30096435546875, 47.01397113616876],[16.50421142578125, 47.00086080525214],[16.449279785156246, 47.202776377962714],[16.45751953125, 47.37975438400816],[16.6827392578125, 47.50050343862717],[16.64703369140625, 47.62467785241324],[16.446533203125, 47.65983792850961],[16.600341796875, 47.76702233051035],[16.754150390625, 47.69312564683551],[17.0947265625, 47.711609647845975],[17.02056884765625, 47.8666165573186],[17.1551513671875, 48.01381248943335],[17.08648681640625, 48.04320138974932],[16.9244384765625, 48.272225451004324],[16.86126708984375, 48.381793961204984],[16.94915771484375, 48.5493419587775],[16.89697265625, 48.72358515157852],[16.6717529296875, 48.73807825631017],[16.4630126953125, 48.808672325527844],[16.35040283203125, 48.73445537176822],[15.98236083984375, 48.783342285295475],[15.83404541015625, 48.88458571785511],[15.757141113281248, 48.84302835299516],[15.28472900390625, 48.982019588328214],[15.16387939453125, 48.94054322456003],[15.147399902343752, 48.99283383694351],[14.999084472656248, 49.01085236926211],[14.974365234375, 48.783342285295475],[14.820556640625, 48.785151998043155],[14.7216796875, 48.68189420361741],[14.7052001953125, 48.58750908593607],[14.59808349609375, 48.62746280105111],[14.474487304687498, 48.64561313162894],[14.400329589843748, 48.580241377838234],[14.3316650390625, 48.55661410872126],[14.20806884765625, 48.58932584966975],[14.01031494140625, 48.634723716904],[14.06524658203125, 48.66557095325139],[13.8482666015625, 48.77067246880509],[13.80706787109375, 48.596592251456705],[13.7274169921875, 48.511146022547344],[13.51318359375, 48.58932584966975],[13.44451904296875, 48.55661410872126]]]}}';
    var austria_poly = JSON.parse(austria_outline_json);

    var min_Rad = 100000000;
    var max_Rad = 0;
    var lower_bound;
    var upper_bound;

    var items = {};

    // Get JSON list of places
    $.getJSON( "http://sfws.lfrz.at/json.php",{command: "getstations"}).done(function(data){
        $.each( data, function( key, val ) {
            items[key] = {
                "n": val.n,
                "x": val.x,
                "y": val.y,
                "lat":((-0.00767*val.y)+49.00947),  // Magic numbers!
                "lng":((0.011317*val.x)+9.516872),
                "val":0.0
            };
        });
        $.getJSON( "http://sfws.lfrz.at/json.php",{command: "getdata"}).done(function(data){
            $.each( data.values, function( key, val ) {
                items[key].val = val.v;
                if(val.v > max_Rad){
                    max_Rad = val.v;
                }
                if(val.v < min_Rad){
                    min_Rad = val.v;
                }
            });
            console.log({min_Rad,max_Rad});
            build_heatmap(items);
        });
        
    });


    function build_heatmap(items){
        
        // Update bounds for graphics now
        lower_bound = Math.floor(min_Rad/increments)*increments;
        upper_bound = Math.ceil(max_Rad/increments)*increments;

        // Visibility flags
        var show_austria        = false;
        var show_raw_points     = false;
        var show_raw_centres    = true;
        var show_tin_polygons   = false;
        var show_grid_points    = true;
        var show_isobands       = false;

        // Options are:
        // 'nearest-vertex' 
        // 'vertex-average'
        // 'interpolate'
        // 'interpolate-native'
        var calc_method = 'interpolate-native';

        // Add outline of Austria to map
        if(show_austria){
            L.geoJson(austria_poly,{fillOpacity:0.5, weight:2, color:'#ffffff'}).addTo(map);
        }

        // Create an array of points from the heatmap data values (TODO : move this into $.getJSON above in future)
        var rawDataArray = [];
        $.each(items, function(k,v){
            var loc = turf.point([v.lng, v.lat], {radiation: v.val});
            rawDataArray.push(loc);
        });

        // Create featureCollection of unstructured data points
        var rawDataPoints = turf.featureCollection(rawDataArray);

        // Add unique identifier to each point (used later on to get them from the TIN coords)
        var index = 0;
        rawDataPoints.features.forEach(function(feat) {
            feat.properties.ref = index;
            index++;
        });


        // Add unstructured data points to map
        if(show_raw_points){
            rawDataPoints.features.forEach(function(feat) {
                var lat = feat.geometry.coordinates[1];
                var lng = feat.geometry.coordinates[0];
                L.circle([lat,lng], feat.properties.radiation*100, {stroke: false, fillOpacity: 0.7, color: '#0000ff'}).addTo(map);
            });
        }

        // Add centre points for unstructured data points to map
        if(show_raw_centres){
            L.geoJson(rawDataPoints, {
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, {
                        radius: 4,
                        fillColor: "#000",
                        color: "#000",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    });
                }
            }).addTo(map);
        }
     
        // Create TIN polygons
        var tin_polys = turf.tin(rawDataPoints, 'ref');
        L.geoJson(tin_polys,{
            onEachFeature: function (feature, layer) {
                var radiation_sum = 0;
                rawDataPoints.features.forEach(function(feat) {
                    if(feat.properties.ref == feature.properties.a){
                        radiation_sum += feature.properties.radiation;
                    }
                    if(feat.properties.ref == feature.properties.b){
                        radiation_sum += feature.properties.radiation;
                    }
                    if(feat.properties.ref == feature.properties.c){
                        radiation_sum += feature.properties.radiation;
                    }
                });
                feature.properties.radiation = (feature.properties.a+feature.properties.b+feature.properties.c)/3;
        }});

        // Add TIN polygons to the map
        if(show_tin_polygons){
            L.geoJson(tin_polys,{
                style: function(feature){
                    var opts = {
                        fillOpacity:    0.5,
                        weight:         1,
                        color:          '#000000',
                        fillColor:      perc2color(rad2perc(feature.properties.radiation))
                    };
                    return opts;
                }
            }).addTo(map);
        }

        // Build the structured overlay grid
        var grid_extent = [9.25, 46.25, 17.45, 49.1];
        var options = {units: 'kilometres'};
        var grid = turf.pointGrid(grid_extent, cellSide, options);

        // Trim structured grid to points within the Austria polygon only
 //       var ptsWithin = turf.pointsWithinPolygon(grid, austria_poly);
        var ptsWithin = grid;

        // Choose which method to calculate the radiation value for the points by
        switch(calc_method){

            // Method A: Calculate which TIN polygon each point lies within
            case 'vertex-average':
                L.geoJson(ptsWithin, {
                    onEachFeature: function (feature, layer) {
                        tin_polys.features.forEach(function(tin_feat) {
                            if(turf.booleanPointInPolygon(feature,tin_feat)){
                                feature.properties.radiation = tin_feat.properties.radiation;
                                return false; // break out of forEach to save computation cycles
                            }
                        });
                    }
                });
                break;

            // Method B: Calculate which unstructured data point each point is nearest to    
            case 'nearest-vertex': 
                L.geoJson(ptsWithin, {
                    onEachFeature: function (feature, layer) {
                        var near_point = turf.nearestPoint(feature,rawDataPoints);
                        feature.properties.radiation = near_point.properties.radiation;
                    }
                });        
                break; 

            // Method C: Calculate a weighted average to the three corners
            case 'interpolate': 
                L.geoJson(ptsWithin, {
                    onEachFeature: function (feature, layer) {

                        // 1: Get which polygon we are inside
                        tin_polys.features.forEach(function(tin_feat) {
                            if(turf.booleanPointInPolygon(feature,tin_feat)){

                                // 2: Get the points on the corner of this polygon
                                var nearest_points = [];
                                rawDataPoints.features.forEach(function(feat) {
                                    if(feat.properties.ref == tin_feat.properties.a){
                                        nearest_points.push(feat);
                                    }
                                    if(feat.properties.ref == tin_feat.properties.b){
                                        nearest_points.push(feat);
                                    }
                                    if(feat.properties.ref == tin_feat.properties.c){
                                        nearest_points.push(feat);
                                    }
                                });

                                // 3: Calculate an interpolation between these points
                                var distances = [
                                    turf.distance(feature,nearest_points[0]),
                                    turf.distance(feature,nearest_points[1]),
                                    turf.distance(feature,nearest_points[2])
                                ];
                                var dist_sum = distances[0]+distances[1]+distances[2];
                                var radiations = [
                                    nearest_points[0].properties.radiation,
                                    nearest_points[1].properties.radiation,
                                    nearest_points[2].properties.radiation
                                ];

                                var this_radiation = ((dist_sum-distances[0])/dist_sum)*radiations[0];
                                this_radiation += ((dist_sum-distances[1])/dist_sum)*radiations[1];
                                this_radiation += ((dist_sum-distances[2])/dist_sum)*radiations[2];

                                feature.properties.radiation = this_radiation/2;

                                return false; // break out of forEach to save computation cycles
                            }
                        });
                    }
                });

                break;   
            case 'interpolate-native': 

                var ptsWithin = turf.interpolate(rawDataPoints, cellSide, {
                    gridType: 'points',
                    property: 'radiation',
                    units: 'kilometres',
                    weight: 10
                })
            
                break;
        }

        // Add structured grid points to map
        if(show_grid_points){
            L.geoJson(ptsWithin, {
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, {
                        // Stroke properties
                        color: '#000',
                        opacity: 0.75,
                        weight: 2,
                        stroke: false,

                        // Fill properties
                        fillColor: perc2color(rad2perc(feature.properties.radiation)),
                        fillOpacity: 1,
                        radius: 6
                    });
                }
            }).addTo(map);
        }

        // Calculate isoband intervals and properties
        var breaks = [];
        var band_properties = [];
        for(i=lower_bound; i<=upper_bound; i+=increments){
            breaks.push(i);
            band_properties.push({radiation_lower:i});
        }

        // Create the isobands
        var isobands = turf.isobands(ptsWithin,breaks,{zProperty: 'radiation', breaksProperties: band_properties});

        // Crop them to the size of Austria (which is the only area we have valid data for)
        // We use Martinez for this
        var croppedisobands_array = [];
        L.geoJson(isobands, {
            onEachFeature: function (feature, layer) {
                croppedisobands_array.push({
                    type: "Feature",
                    properties: feature.properties,
                    geometry: {
                        type: "MultiPolygon",
                        coordinates: martinez.intersection(feature.geometry.coordinates,austria_poly.geometry.coordinates)
                    }
                });
            }
        });  
        var croppedisobands = turf.featureCollection(croppedisobands_array);  

        // Draw isobands
        if(show_isobands){
            L.geoJson(croppedisobands,{
                onEachFeature: function(feature, layer){
                    if (feature.properties && feature.properties.radiation) {
                        layer.bindPopup(feature.properties.radiation);
                    }
                },
                style: function(feature){
                    var opts = {
                        fillOpacity:    0.9,
                        weight:         1,
                        stroke:         false,
                        color:          '#000000',
                        fillColor:      perc2color(rad2perc(feature.properties.radiation_lower)),
                    };
                    return opts;
                }
            }).addTo(map);
        }

    }

    // Scales a radiation value between the maximum and minimum possible values
    function rad2perc(rad_values){
        return (rad_values-lower_bound)*100/(upper_bound-lower_bound);       
    }

    // Return a hex colour from red -> yellow -> green depending upon input percentage (0 -> 100)
    function perc2color(perc) {
        var r, g, b = 0;

        perc = 100-perc; // invert so green = low number

        if(perc < 50) {
            r = 255;
            g = Math.round(5.1 * perc);
        }
        else {
            g = 255;
            r = Math.round(510 - 5.10 * perc);
        }
        var h = r * 0x10000 + g * 0x100 + b * 0x1;
        return '#' + ('000000' + h.toString(16)).slice(-6);
    }
};
</script>
</body>
</html>